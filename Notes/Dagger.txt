-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
											DAGGER - 2
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Dagger-2 is the official dependency injection framework for Android (Its developed by google, recommends is)
* Dagger-2 is the most popular Dependency Injection Framework

Dagger History:

* Dagger 1 developed by Square ,deprecated
* Google adapted Dagger and then developed Dagger-2 which is a different implementation of Dagger-1
* dagger.android, google developed a different DIF which is part of Dagger-2, its Deprecated
* Dagger Hilt, early alpha (latest release from Google)

Today Dagger is referred to as "Dagger-2"

Dagger is generally considered the most complex dependency injection framework in Android world

Gradle Configuration:
----------------------

open dagger2 git hub
https://github.com/google/dagger

go to "gradle" in Readme.md

  // Add Dagger dependencies
dependencies {
  api 'com.google.dagger:dagger:2.x'
  annotationProcessor 'com.google.dagger:dagger-compiler:2.x'
}


Reafactoring projecct with Dagger-2 Conventions

annotate the PresentationCompositionRoot with "@Module" and rename the PresentationCompositionRoot class into
Dagger-2 conventions of naming with suffix "Module", hence rename of file is PresentationModule

Every service(object instance shared to client(activity/fragment) of using the CompositionRoot) inside the module(PresentationModule) needs to be annotated using "@Provides". Each service / object cant be a variable(val/var) it has to be a function with "@Provides"

Step 1:
--------
val screensNavigator get() = activityCompositionRoot.screensNavigator            
	                     
																	Transformed into====>
@Provides
fun screensNavigator() = activityCompositionRoot.screensNavigator


Step 2:
--------

@Provides
fun stackoverflowApi() = activityCompositionRoot.stackoverflowApi

@Provides
fun fetchQuestionDetailsUseCase() = FetchQuestionDetailsUseCase(stackoverflowApi) // its a error because
														// stackoverflowApi is a function now, we can resolve it by

@Provides
fun fetchQuestionDetailsUseCase() = FetchQuestionDetailsUseCase(stackoverflowApi())

															but	in dagger it has to be Transformed into====>
@Provides
fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)
											// Dagger2 will get stackoverflowApi from "fun stackoverflowApi()"
											// pass the stackoverflowApi instance into this 
											// fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi)
											// which will be passed into 
											// FetchQuestionDetailsUseCase(stackoverflowApi) 

							

In dagger we cant use presentationModule(@Module) directly into the client(Activity/Fragment), we have to
define the component as an Interface using @Component annotation (in our case "PresentationComponent"). 
something like a wrapper around dagger module(presentationModule)


@Component (modules = [PresentationModule::class])
interface PresentationComponent {
}

We defined a Interface which is annotated as Dagger Component, to the interface we pass a list of 
Dagger Modules which the Interface should use. Once Dagger component uses some modules, it immediately gets
access to the services(@provides) inside the module. 

@Component (modules = [PresentationModule::class])
interface PresentationComponent {
    fun screensNavigator(): ScreensNavigator
    
    fun viewMvcFactory(): ViewMvcFactory

    fun dialogsNavigator(): DialogsNavigator

    fun fetchQuestionsUseCase(): FetchQuestionsUseCase

    fun fetchQuestionDetailsUseCase(): FetchQuestionDetailsUseCase
}
 
Shouldnt talk/use Dagger modules directly, should only use Dagger components and the Dagger components is an
abstraction over module, the implementation of Dagger component interface will be generated/defined by the 
Dagger using the Module defined in the component.

Dagger operates on annotationProcessing and cold generation approach, dagger process all the annotations
defined by us (component(PresentationComponent(I)), module(PresentationModule(C)), provides(functions in 
PresentationModule)), and then based on the annotations it generates code. the generated code includes 
implementaion of PresentationComponent and prefix it with "Dagger" name. 
DaggerPresentationComponent is the class generated by dagger according to the specification of 
PresentationComponent(I) and specification of PresentationModule(C).


Application-Scope						AppCompositionRoot
												^
												|
-----------------------------------------------------------------------------------								
Activity-Scope							ActivityCompositionRoot
-----------------------------------------------------------------------------------
												^
												|
Presentation-Scope						PresentationComponent
	or 											^
Controller-Scope								|
										    Injector
												^
												|
										Activities and Fragments


PresentationModule will exactly replace the PresentationCompositionRoot, but why we need 
PresentationComponent?
PresentationComponent fulfills a different Role

Dagger Conventions:
-------------------
* Components are interfaces annotated with @Component annotation, @Component annotation will take a
list of modules

* Modules are classes annotated with @Module annotation, Module are basically compositionRoot.

* Methods in modules that provides services are annotated with @Provides annotation, If a specific
component uses a module and inside that module you have a provider method, the component will automatically
will get access to that service and can use it

* provided services(stackoverflowApi) can be used as method arguments in other provider methods(fetchQuestionDetailsUseCase). whenever if we need some additional service to construct another service, define
the service as an argument to provider method, dagger will figure out and satisfy the dependency 

-------------------------------
			Scopes:
-------------------------------
@Module
class ActivityModule(
        val activity: AppCompatActivity,
        private val appComponent: AppComponent
) {

    private val screensNavigator by lazy {
        ScreensNavigator(activity)
    }

}

In the above module we can see that screensNavigator is intantiated lazy, which means that the 
screensNavigator will be intantiated only when its used/called for the first time. after that
the same instance is shared with the clients, its not instantiated everytime when its called.
It has the scope of the same instance of ActivityModule and ActivityComponent. If a different
ActivityComponent and ActivityModule instance is created, then the instance of the ScreensNavigator will
be different.
The "scope" of the instance of the ScreensNavigator is tied to the instance lifetime of the 
ActivityComponent/ActivityModule. This can be defined using lazy{} locally for every specific services

This scope can be defined for Module wise

step 1: define a annotation class for the ActivityModule
	
	import javax.inject.Scope
	
	@Scope
	annotation class ActivityScope {
	
	}

step 2:

//screensNavigator is shared to client using method screensNavigator() which inturn returns the
screensNavigator(field). screensNavigator(field) is instantiated lazy, means will create the 
screensNavigator(field) instance for first time of call, thenafterwards will return the same instance
to the client, its screensNavigator lifetime is tied to the lifetime of the client(Activity).

@Module
class ActivityModule(
        val activity: AppCompatActivity,
        private val appComponent: AppComponent
)
{

    private val screensNavigator by lazy {
        ScreensNavigator(activity)
    }

    @Provides
    fun screensNavigator(activity: AppCompatActivity) = screensNavigator
}

we can remove the above external way of defining the scope by using lazy {} with the below 
way of defining a Dagger scope to the screensNavigator()

@Module
class ActivityModule(
        val activity: AppCompatActivity,
        private val appComponent: AppComponent
)
{
    @Provides
    @ActivityScope // Scope Bindings, same as instantiating using lazy{} way
    fun screensNavigator(activity: AppCompatActivity) = ScreensNavigator(activity) // intantiate here itself

}

If we define/use a "scope bindings" inside a module(in our case ActivityModule), we have to define the scope binding is used to the component(ActivityComponent) of the module used.

// to intimate this component(ActivityComponent) that "ActivityScope" is used in the specified module(ActivityModule)

@ActivityScope 
@Component(modules = [ActivityModule::class])
interface ActivityComponent {

    fun activity(): AppCompatActivity

    fun layoutInflater(): LayoutInflater

    fun fragmentManager(): FragmentManager

    fun stackoverflowApi(): StackoverflowApi

    fun screensNavigator(): ScreensNavigator

}

//// we can also use predefined scope (@Singleton) which is defined in all DIF(dependency injection frameworks)

Define @Singleton at the service level and also at the component defenition, as we did it for userdefined scope

@Singleton
@Component(modules = [AppModule::class])
interface AppComponent {

    fun application(): Application
    fun stackoverflowApi(): StackoverflowApi

}

and module is 

@Module
class AppModule(val application: Application) {

    private val retrofit: Retrofit by lazy {
        Retrofit.Builder()
                .baseUrl(Constants.BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build()
    }

    private val stackoverflowApi: StackoverflowApi by lazy {
        retrofit.create(StackoverflowApi::class.java)
    }

    @Provides
    fun application() = application

    @Provides
    fun stackoverflowApi() = stackoverflowApi

}

is changed into as below as "retrofit is refactored as method ""

@Module
class AppModule(val application: Application) {

    @Singleton
    @Provides
    fun retrofit(): Retrofit {
        return Retrofit.Builder()
                .baseUrl(Constants.BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build()
    }

    @Provides
    fun application() = application

    @Singleton
    @Provides
    fun stackoverflowApi(retrofit: Retrofit) = retrofit.create(StackoverflowApi::class.java)

}

/// retrofit is refactored as field value, using @Singleton scope

@Module
class AppModule(val application: Application) {

    @Singleton
    @Provides
    private val retrofit: Retrofit by lazy {
        Retrofit.Builder()
                .baseUrl(Constants.BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build()
    }

    @Provides
    fun application() = application

    @Singleton
    @Provides
    fun stackoverflowApi() = retrofit.create(StackoverflowApi::class.java)

}


/////// Avoid using @Singleton scope as it deviates the meaning, whether the value is
"scope" or it should have only single instance in the life time of the application, same
code is refactored using custom defined scope

//define a custom scope file "AppSCope.kt"

import javax.inject.Scope

@Scope
annotation class AppScope {
}

// use the custom defined "AppScope" in the Component and the Module
// Component is "AppComponent" is defined with custom scope

@AppScope
@Component(modules = [AppModule::class])
interface AppComponent {

    fun application(): Application
    fun stackoverflowApi(): StackoverflowApi

}

// Module is "AppModule", its services are @Provides which are efined with custom scope

@Module
class AppModule(val application: Application) {

    @AppScope
    @Provides
    fun retrofit(): Retrofit {
        return Retrofit.Builder()
                .baseUrl(Constants.BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build()
    }

    @Provides
    fun application() = application

    @AppScope
    @Provides
    fun stackoverflowApi(retrofit: Retrofit) = retrofit.create(StackoverflowApi::class.java)

}

----------Dagger Convention (@Scope)--------------------
	* Scopes are annotations, annotated with @Scope
	* Components that provide scoped services must be Scoped
	* All clients get the same instance of a Scoped service "from the same instance" of a Component.
		(service instance of the defined scope will be cached until the life time of the component)



---------------------------------------------------------------------------------------------------
		MORE CONVENTIONS FROM DAGGER - USAGE AS INJECTOR
---------------------------------------------------------------------------------------------------
Injector role is to search for the client classes(which is passed via inject() method)
and find the appropriate place to inject the appropriate services which is defined inside
the Injector class(the component which contains the supported services is passed to Injector)


class Injector(private val component: PresentationComponent) {

    fun inject(client: Any) { // this is the method called by the client(activity / fragment)
        for (field in getAllFields(client)) {
            if (isAnnotatedForInjection(field)) {
                injectField(client, field)
            }
        }
    }

    private fun getAllFields(client: Any): Array<out Field> {
        val clientClass = client::class.java
        return clientClass.declaredFields
    }

    private fun isAnnotatedForInjection(field: Field): Boolean {
        val fieldAnnotations = field.annotations
        for (annotation in fieldAnnotations) {
            if (annotation is Service) {
                return true
            }
        }
        return false
    }

    private fun injectField(client: Any, field: Field) {
        val isAccessibleInitially = field.isAccessible
        field.isAccessible = true
        field.set(client, getServiceForClass(field.type))
        field.isAccessible = isAccessibleInitially
    }

    private fun getServiceForClass(type: Class<*>): Any {
        when (type) { // these are the services supported for injection into the client, the services are
        				// used or fetched from the component passed into this injector
            DialogsNavigator::class.java -> { 
                return component.dialogsNavigator()
            }
            ScreensNavigator::class.java -> {
                return component.screensNavigator()
            }
            FetchQuestionsUseCase::class.java -> {
                return component.fetchQuestionsUseCase()
            }
            FetchQuestionDetailsUseCase::class.java -> {
                return component.fetchQuestionDetailsUseCase()
            }
            ViewMvcFactory::class.java -> {
                return component.viewMvcFactory()
            }
            else -> {
                throw Exception("unsupported service type: $type")
            }
        }
    }


}


// Dagger supports this Injection methodology by itself, to make use of Dagger injection but not depend on
the Injector class for injection into the client. below steps describes to use Dagger Injection


* fields/properties shouldnt be private, Dagger uses "code generation" not "reflection". Hence need to
make the fields to be accessible from outside.

* prefix the field with "@Inject" annotation, to let dagger know the field should be set with the 
appropriate service defined in the module.


Since dagger do injection by itself, we dont need a external Injection class to inject into the 
client, Hence we dont need to define the component Interface with the methods(which provide the service)

@Component(modules = [PresentationModule::class])
interface PresentationComponent {

    fun viewMvcFactory(): ViewMvcFactory

    fun screensNavigator(): ScreensNavigator

    fun dialogsNavigator(): DialogsNavigator

    fun fetchQuestionsUseCase(): FetchQuestionsUseCase

    fun fetchQuestionDetailsUseCase(): FetchQuestionDetailsUseCase

}

Above methods are needed only for the external injection class to fetch the services from the 
component(PresentationComponent) and set it to the client

Since Dagger is capable of doing the injection by itself, we dont need to define those methods
which exposes the services as defined in the module.

we can redefine the Component class like


@Component(modules = [PresentationModule::class])
interface PresentationComponent {
    fun inject(activity: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

the client in our case can use this inject method and define the fields to be injected with
the annotation "@Inject"

class QuestionsListFragment : BaseFragment(), QuestionsListViewMvc.Listener {

    @Inject lateinit var fetchQuestionsUseCase: FetchQuestionsUseCase
    @Inject lateinit var dialogsNavigator: DialogsNavigator
    @Inject lateinit var screensNavigator: ScreensNavigator
    @Inject lateinit var viewMvcFactory: ViewMvcFactory

    override fun onCreate(savedInstanceState: Bundle?) {
        injector.inject(this)
        super.onCreate(savedInstanceState)
    }
}

class QuestionDetailsActivity : BaseActivity(), QuestionDetailsViewMvc.Listener {

    @Inject lateinit var fetchQuestionDetailsUseCase: FetchQuestionDetailsUseCase
    @Inject  lateinit var dialogsNavigator: DialogsNavigator
    @Inject  lateinit var screensNavigator: ScreensNavigator
    @Inject  lateinit var viewMvcFactory: ViewMvcFactory

	override fun onCreate(savedInstanceState: Bundle?) {
        injector.inject(this)
        super.onCreate(savedInstanceState)
    }
}

//Dagger will inject the services of the client with the services defined in the module(PresentationModule)
    

Application-Scope						AppComponent
												^
												|
-----------------------------------------------------------------------------------								
Activity-Scope							ActivityComponent
-----------------------------------------------------------------------------------
												^
												|
Presentation-Scope						PresentationComponent
	or 											^
Controller-Scope								|
												|
										Activities and Fragments


Hence Components in Dagger are Basically "Injectors". 
Modules are compositionRoot, they construct objects/services and then components know to take these
constructed components and inject them into the clients 

---_Dagger Convention (@Inject)---------------------
	* Void methods with single arguments defined on components, generate injectors for the
	type of the argument defined in client (Eg: If you want to Inject fields in client(QuestionListFragment) then we need to define a function in the Component(PresentationComponent), the function should receive the
	QuestionListFragment as a argument), the function name is not mandatory to be named as "inject()"
	it can be anything, but the passed argument should be the type of client(QuestionListFragment) and it 
	should noot contain return type

	* Clients non-private and non-final properties (fields ) annotated with "@Inject" designate injection
	targets (field with @Inject defined are the destination of the injection, those fields shouldnt be private fields, if its Dagger cant inject into those fields because dagger use annotations not reflection)



----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
								DEPENDENT COMPONENTS
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

Inside a component, Eg: PresentationComponent, which internally uses PresentationModule to expose the 
services to clients. Inside PresentationModule, we could see some methods like (fragmentManager(), 
layoutInflater(), stackoverflowApi()) which we get from the construction parameter(activityComponent)
that are required to build the actual services needed by the client(viewMvcFactory(), dialogsNavigator()
, fetchQuestionsUseCase()). these methods (fragmentManager(), layoutInflater(), stackoverflowApi()) are not
needed by the client, but they are needed to build the services required by the client(QuestionDetailsActivity).
We still needs "@Provides" for these (fragmentManager(), layoutInflater(), stackoverflowApi()) methods to be
used with in the Module to generate services for the client. "@Provides" convention of dagger, unnecessarly
expose this internally used methods outside to client which can be avoided using a different convention
by Dagger, that will avoid this exposure outside of the Module/component


@Module
class PresentationModule(private val activityComponent: ActivityComponent) {

    @Provides
    fun layoutInflater() = activityComponent.layoutInflater() // this is used internally, shouldnt be exposed
                                                              // outside,
    @Provides
    fun fragmentManager() = activityComponent.fragmentManager()

    @Provides
    fun stackoverflowApi() = activityComponent.stackoverflowApi()

    @Provides
    fun activity() = activityComponent.activity()

    @Provides
    fun screensNavigator() = activityComponent.screensNavigator()

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)

    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}

To avoid using the ActivityComponent methods exposed outside from PresentationComponent and also
use all the activityComponent Methods used inside the PresentationComponent and PresentationModule for its internal purpose

add "dependencies" to the PresentationComponent defenition along with the "modules" defenition


@Component(dependencies = [ActivityComponent::class], modules = [PresentationModule::class])
interface PresentationComponent {
    fun inject(activity: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

by the above convention of "dependencies" defined for PresentationComponent, Now PresentationComponent
depends upon ActivityComponent. All the modules used by the PresentationComponent(in our case its
PresentationModule) will get access to all the services exposed in ActivityComponent. 

presentationmodule looks like


@Module
class PresentationModule(private val activityComponent: ActivityComponent) {

    @Provides
    fun layoutInflater() = activityComponent.layoutInflater()

    @Provides
    fun fragmentManager() = activityComponent.fragmentManager()

    @Provides
    fun stackoverflowApi() = activityComponent.stackoverflowApi()

    @Provides
    fun activity() = activityComponent.activity()

    @Provides
    fun screensNavigator() = activityComponent.screensNavigator()

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)

    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}

After adding ActivityComponent added as a dependency to the PresentationComponent, internally dagger will
provide the services of ActivityComponent exposed services to all the modules mentioned in PresentationComponent
modules list. and PresentationModule will be refactored like below mentioned

@Module
class PresentationModule() {
    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)

    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}

Now no need to explicitly get the ActivityComponent inside the PresentationModule and use the methods, to supply
into the PresentationModule dependencies of ActivityComponent services. ActivityComponent services are automatically injected into the PresentationModule

If we want PresentationComponent to be dependent on ActivityComponent. We need to make the PresentationComponent
to be "Scope". Since ActivityComponent has services with "Scope", ActivityComponent is defined with "Scope" because of the services exposed by it using "Scope". Since ActivityComponent has "Scope", we need to make 
PresentationComponent to have its own "Scope" to enable or make the ActivityComponent as dependencies for 
PresentationComponent(Dagger rule is that, if a component support "Scope"  and its is made as a dependency 
to another Component, the other component must support "Scope")

Introducing "PresentationScope" to PresentationComponent

@PresentationScope
@Component(dependencies = [ActivityComponent::class], modules = [PresentationModule::class])
interface PresentationComponent {
    fun inject(activity: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

//Now need to make changes to construction of PresentationComponent, since ActivityComponent is made
dependency for PresentationComponent

    val activityComponent by lazy {
        DaggerActivityComponent.builder()
                .activityModule(ActivityModule(this, appCompositionRoot))
                .build()
    }

   private val presentationComponent by lazy {
        DaggerPresentationComponent.builder()
                .activityComponent(activityComponent) // passing activityComponent Instance when building
                .presentationModule(PresentationModule())
                .build()
    }


------------- Dagger Convention "dependencies" Summary---------------------
*	Component inter-dependencies  are specified as part of @Component annotation
*	Component-B that depends on Component-A has implicit access to all services exposed by Component-A
		*	services from A can be injected by B (Eg: if ActivityComponent exposes a service of "fragmentManager"
				and if a client requires a "fragmentManager", PresentationComponent will be able to inject the
				"fragmentManager" to the client. because PresentationComponent depends on ActivityComponent)
		* 	services from A can be consumed inside modules of B (Eg: services that are exposed by ActivityComponent can be just consumed inside PresentationModule and we dont need to explicitly provide it
		again inside PresentationModule and dont need to know about the ActivityComponent inside PresentationModule)

This "dependencies" convention removes lot of code duplication.


-----------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
											SUBCOMPONENTS
-----------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------

By using the convention "dependencies" in PresentationComponent, mentioning ActivityComponent::class as the dependency of the PresentationComponent. We avoid redefenition of the services supplied by ActivityComponent(all services of ActivityComponent) inside the PresentationComponent to use those inside the PresentationComponent in building the PresentationComponent services which is exposed to client, 


The ActivityComponent services are only used by the PresentationComponent. Futher more we can avoid explicit defenition of the services exposed by ActivityComponent. As ActivityComponent
services are composed of redefenition services of AppComponent (ActivityComponent redefine the "stackoverflow" service in ActivityComponent and its not defined in ActivityModule but it gets it from its dependency(AppComponent) to use the stackoverflow service inside the PresentationComponent)  and some native ActivityComponent services, all these services are used by PresentationComponent to build its services.

By making the PresentationComponent as the subcomponent of ActivityComponent (which is something like making PresentationComponent as the subclass of ActivityComponent). The services available to ActivityComponent from
AppComponent(AppComponent is the dependencies of ActivityComponent) and the services defined inside the ActivityModule are automatically available or can be injected by dagger to the PresentationComponent without the explicit defenition of services inside the ActivityComponent. 

No need to defined the services exposed by the ActivityComponent explicitly inside the ActivityComponent(I). Instead we need to declare/define a method in ActivityComponent(I) which accepts PresentationModule instance as the parameter of the function and returns a PresentationComponent(return value of the method). Dagger will inject all the necassary services exposed by AppComponent(AppComponent is the Dependency of ActivityComponent) and ActivityComponent into the PresentationModule and builds all the services exposed by PresentationComponent which can be used by client.

"vasiley" => Before we use "dependencies" component, we provide the stackoverflow APi from AppModule class. Before
we use "dependencies" components we had this stackoverflow API provider method in ActivityModule explicitly using (@Provides) to use with in the ActivityModule to build ActivityModule services and also we want it to pass it to PresentationModule. 
	After using "dependencies" convention, we dont have trace(removed the explicit defenition of stackoverflow API) inside ActivityModule and we can still use it inside the PresentationModule because PresentationComponent dependes("dependencies") on ActivityComponent and ActivityComponent dependes ("dependencies")
	on AppComponent and AppComponent exposes stackoverflow API and ActivityComponent re-exposes stackoverflow API.
	Eventhough there is not Trace of  stackoverflow API inside ActivityModule, PresentationComponent still gets the stackoverflow API from ActivityComponent(depends on AppComponent). This approach of using "dependencies" mentioned is better than previous of not using "dependencies" because we dont need to re-define/ re-expose the
	services inside modules.

Still we can improve this, Can we leverage convention of "dependencies" components to remove the unneeded provider method of stackoverflow APi inside ActivityComponent. is there a convention to remove the explicit declaration of the services that ActivityComponent provides to PresentationComponent. Dagger know that stackoverflow Api is provided by AppComponent/AppModule and Dagger know that stackoverflow API is used in PresentationModule.
The elimintation of  explicit declaration of services provided by ActivityComponent and AppComponent(stackoverflow API) can be done by a convention using "subcomponent".

Currently PresentationComponent depends on ActivityComponent using "dependencies" and ActivityComponent need to expose the servies to be used by PresentationCOmponent. When PresentationComponent declares a method that it can
Inject into QUestionListFragment(client) using "fun inject(fragment: QuestionListFragment)" doesnt need information or declaration on what all services need to be injected into the QuestionListFragment(client)
When the application, during annotation and code generation process, Dagger goes and looks at the implementation
of client(QUestionListFragment) and notices that it needs to injecct the services which are annotated with 
@Inject, Dagger will generate a injector which is cable to inject those services needed by client
Here we make the ActivityComponent as an Injector into the presentationComponent, Dagger during code generation
and annotation processing will look at the services which are declared as a dependencies inside PresentationModule
(layourinflater, fragmentManager, stackoverflowApi) and sees that ActivityComponent can provide those dependencies and then it will inject those dependencies into the PresentationModule like the same way it does it for the client(QuestionsListFragment).


Interfaces and Classes before using the "subcomponent" convention

---------------------------------------------------------------
"PresentationComponent.kt"

@PresentationScope
@Component(dependencies = [ActivityComponent::class], modules = [PresentationModule::class])
interface PresentationComponent {

    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}
---------------------------------------------------------------

"ActivityComponent.kt"

@ActivityScope
@Component(dependencies = [AppComponent::class], modules = [ActivityModule::class])
interface ActivityComponent {
    fun activity(): AppCompatActivity
    fun layoutInflater(): LayoutInflater
    fun fragmentManager(): FragmentManager
    fun stackoverflowApi(): StackoverflowApi
    fun screensNavigator(): ScreensNavigator
}
---------------------------------------------------------------
"ActivityModule.kt"

@Module
class ActivityModule(
        val activity: AppCompatActivity
) {

    @Provides
    fun activity() = activity

    @Provides
    @ActivityScope
    fun screensNavigator(activity: AppCompatActivity) = ScreensNavigator(activity)

    @Provides
    fun layoutInflater(activity: AppCompatActivity) = LayoutInflater.from(activity)

    @Provides
    fun fragmentManager(activity: AppCompatActivity) = activity.supportFragmentManager

}
---------------------------------------------------------------
"PresentationModule.kt"

@Module
class PresentationModule() {

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)

    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}
---------------------------------------------------------------
Building the ActivityComponent and PresentationComponent


open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        DaggerActivityComponent.builder()
                .appComponent(appComponent)
                .activityModule(ActivityModule(this))
                .build()
    }

    private val presentationComponent by lazy {
        DaggerPresentationComponent.builder()
                .activityComponent(activityComponent)
                .presentationModule(PresentationModule())
                .build()
    }

    protected val injector get() = presentationComponent
}
---------------------------------------------------------------
---------------------------------------------------------------
	After using the "subcomponent" convention from dagger, the code below looks like this
---------------------------------------------------------------	
---------------------------------------------------------------

We are making PresentationComponent as a SubComponent of ActivityComponent, 
Hence we change the "@Component" annotation of PresentationComponent into "@Subcomponent" annotation and it doesnt have "dependencies" component, has "modules" component

@PresentationScope
@Subcomponent(modules = [PresentationModule::class])
interface PresentationComponent {

    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

WE can get rid of all the services defined inside the ActivityComponent which are required before for PresentationComponent. Make Dagger to infer by itself to provide the services required by the PresentationModule and inject it by itself. WE dont need to expose the services explicitly in ActivityComponent, instead we need to
expose a "Builder method / factory method" which will construct PresentationComponent from ActivityComponent

Convention of the Factory/Builder method which is to be defined inside ActivityCOmponent

fun anyName(modules used by Presentation Component) : PresentationComponent
Eg: fun newPresentationComponent(presentationModule: PresentationModule) : PresentationComponent

@ActivityScope
@Component(dependencies = [AppComponent::class], modules = [ActivityModule::class])
interface ActivityComponent {
    fun newPresentationComponent(presentationModule: PresentationModule): PresentationComponent
}

//Construction of PresentationComponent Changed inside BaseActivity

open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        DaggerActivityComponent.builder()
                .appComponent(appComponent)
                .activityModule(ActivityModule(this))
                .build()
    }

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent(PresentationModule()))
    }

    protected val injector get() = presentationComponent
}

//Construction of PresentationComponent Changed inside BaseFragment

open class BaseFragment: Fragment() {

    private val presentationComponent by lazy {
        (requireActivity() as BaseActivity).activityComponent.newPresentationComponent(PresentationModule())
    }

    protected val injector get() = presentationComponent
}


PresentationComponent is a subComponent of ActivityComponent and ActivityComponent has the factorymethod
to return the new instance of PresentationComponent. Therefore during annotationprocessing and code generation
phase, Dagger compiler will go and look into the PresentationComponent and  find out the dependencies for the services which is supposed to generate (layourinflater, fragmentManager, stackoverflowApi), Dagger compiler will
injecct those dependencies into the PresentationModule and generate the PresentationComponent which inturn will inject the services generated by PresentationComponent into the client (QuestionsListFragment)

-------------------------- Dagger Convention (SubComponent)-------------------
	* Subcomponent specified by @SubComponent annotation

	* Parent Component exposes factory method which return Subcomponent (ActivityComponent will expose the
		factory method to return the instance of PresentationComponent)

	* The argument of factory method are Subcomponent's modules (in our case we pass PresentationModule instance)

	* Subcomponents get access to all services provided by parent (provided, not just exposed. when we used "Dependencies" convention, we still need to expose all the services explicitly in Component Interface defenition, in "SubComponent" convention dagger take care of supplying dependencies and wiring together behind the scenes which will be very useful in bigger applications)

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
								MULTI-MODULE COMPONENTS
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
	concept of expanding on the working of Modules, Modules in Dagger are CompositionRoot, they declare the
	services which dagger know to provide it to the clients. Inside each module we have provider methods(methods
	annotated with @Provides). Modules can have boot-straping dependencies( dependencies passed via consturctor
	into the modules which are required to build module services/objects). Eg: ActivityModule has a Boot-Strap
	dependency of "activity: AppCompatActivity" which is passed into the ActivityModule from outside. ActivityModule cant construct the passed-in object or any of its services without it, 

	Components are basically Dagger's Injetors depends on Modules. Whichever the modules mentioned in the Component
	the services provided by the module. Dagger will be able to inject all the services created by the modules which are mentioned in the components. One component can depend on multiple modules.

	Why we need multiple modules to include in a single component. If we have lot of services to be supported by a module. We can split and organize the multiple services into different modules and then use all those modules
	to be supported by a single component which provides code into more-readable and more-maintenable.

	To know how to use the multi-module in a single component, we extract the usecases in the PresentationModule
	into a different module.

@Module
class PresentationModule() {

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)

    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}

//After refactoring we split the services of PresentationModule to a new Module which is "UseCaseModule"


// contains services relevant to usecases
@Module
class UseCasesModule() {
    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)
}

// contains services relevant to Presentation
@Module
class PresentationModule() {
    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)
}


// we mention the UseCaseModule as a dependencies of Presentation component.

@PresentationScope
@Subcomponent(modules = [PresentationModule::class, UseCasesModule::class])
interface PresentationComponent {

    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

// In BaseActivity we construct this PresentationComponent, we can observe that we pass only the instance of
PresentationModule, but we dont pass the instance of UsecaseMOdule. Because, for dagger we dont need to pass the deendencies modules which doesnt have boot-strap dependenies. If we dont have boot-strap dependencies for modules, we dont need to expsoe them while constructing it.

open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        appComponent.newActivityComponent(ActivityModule(this))
    }

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent(PresentationModule())
    }

    protected val injector get() = presentationComponent
}

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {
    fun newPresentationComponent(presentationModule: PresentationModule): PresentationComponent
}


we dont mention UsecaseModule in constructing PresentationComponent, and we can also remove mentioning
PresentationModule for constructing PresentationCOmponent. Dagger can take care of using module instance(PresentaitonModule and UsecaseModule with in PresentationComponent even if its not mentioned inside PresentationComponent)

In BaseFragment and BaseActivity, constructing presentationCOmponent without mentioning PresentationModule and
UsecaseModule

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {
    fun newPresentationComponent(): PresentationComponent
}


open class BaseFragment: Fragment() {

    private val presentationComponent by lazy {
        (requireActivity() as BaseActivity).activityComponent.newPresentationComponent()
    }

    protected val injector get() = presentationComponent
}

open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        appComponent.newActivityComponent(ActivityModule(this))
    }

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent()
    }

    protected val injector get() = presentationComponent
}

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {
    fun newPresentationComponent(): PresentationComponent
}

//But if we have a BootStrap dependencies for a Module, then we have to defenitely pass the dependencies and
mention those modules with boot-strap dependencies when building the component instance.

We can have one single component dependent on multiple modules and if the module doesnt have any boot-strap
dependencies then Dagger can contruct the component which is dependent on multiple modules by not mentioning those modules in the component construction.

Better to mention the multiple modules when constructing the component even if the module doesnt have any boot-strap dependencies for better readability

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {
    fun newPresentationComponent(presentationModule: PresentationModule, useCasesModule: UseCasesModule): PresentationComponent
}

open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        appComponent.newActivityComponent(ActivityModule(this))
    }

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent(PresentationModule(), UseCasesModule())
    }

    protected val injector get() = presentationComponent
}

open class BaseFragment: Fragment() {

    private val presentationComponent by lazy {
        (requireActivity() as BaseActivity).activityComponent.newPresentationComponent(
                PresentationModule(), UseCasesModule())
    }

    protected val injector get() = presentationComponent
}

------Additional convention on Dagger module which is absolutely critical and important is that -----------------

"Different modules share the same object graph", If we have PresentationComponent and it has 2 modules (PresentationModule and UseCaseModule), whatever we provide in PresentationModule can be used inside 
UsecaseModule. Eg: If PresentationComponent is Standalone( resentationComponent is not a Subcomponent of 
ActivityComponent) also it doesnt have any dependencies from other component(PresentationComponent is not dependent on ActivityComponent). Still PresentationComponent will be able to reusue the services provided by different modules(PresentationModule and UseCaseModule).

For ActivityComponent, the only boot-strap parameter used is "activity: ApppCompactActivity" instance. Its upto developer choice to segregate / chop the services to be offered to client into different modules. PresentationCOmponent in our case doesnt have boot-strap dependency because all the required boot-strap dependencies/servics will come from higher level component(From ActivityComponent and AppComponent).

-----------------Summary of Dagger convention for multiple-Modules in a Component------------------------------

	*	Component can use more than one module (services provided by a component which is a huge object graph can 											  be segregated into multiple modules and all those can be exposed 												by a single component)
	*	Modules of a single component share the same object graph
			(Eg: if you inject activity instance inside a ActivityModule, add additional new module to ActivityComponent then this new module will be able to use the activity instance which is provided to ActivityModule, because the object graph of the Component is shared across the all modules in a Component)  
	* 	Dagger automatically instantiates modules with no-argument constructors. But better to provide 
    modules instances when building the component because it make code more readable.

    Eg::

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent(PresentationModule(), UseCasesModule())
    }


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
								AUTOMATIC DISCOVERY OF SERVICES but its not (CONSTRUCTOR INJECTION)
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

The most powerful Dagger convention.

In PresentationModule, if you look ar dialogsNavigator() service, you can observe the service is provided with fragmentManager. How Dagger know that we are providing DialogsNavigator service/instance? Dagger does annotation processing and see "@Provides" and then it inspects the arguments of the method and then it instantiates DialogsNavigator instance/service for us. It does all this behind the scenes and the end result is that it provides DialogsNavigator service whenever we needs it, Dagger know how to construct this service.

@Module
class PresentationModule() {

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

    @Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)

}

If dagger annotation processor can go into PresentationModule and inspects the context of the presentationModule and sees that we provide DialogsNavigator from here and it also understands that it needs a FragmentManager to construct it and behind the scenes Dagger makes sure that there is a fragmentManager on the object graph. Whenever we construct a DialogsNavigator, we have a place to provide a fragmentManager

	@Provides
	fun dialogsNavigator("fragmentManager: FragmentManager") = DialogsNavigator(fragmentManager)

Why can't Dagger can go and inspect DialogsNavigator class directly, It has a constructor and it needs a fragmentManager value to construct the DialogsNavigator instance

class DialogsNavigator(private val fragmentManager: FragmentManager) {

    fun showServerErrorDialog() {
        fragmentManager.beginTransaction()
                .add(ServerErrorDialogFragment.newInstance(), null)
                .commitAllowingStateLoss()
    }
}

may be instead of providing DialogsNavigator from PresentationModule, May be i can let dagger know by providing the information at the class itself and so that Dagger can inspect the object graph and pass the required instance directly into the constructor itself and construct the DialogsNavigator instance and provide it to client. Theres no need to declare it in the PresentationModule to provide the dependency instance for DialogsNavigator to constuct the DialogsNavigator Instance.

Theres a possiblility, Dagger can provide the service/dependency instance from with in its own class(DialogsNavigator class) and dont need to add additional code inside the Presentationmodule and make the Dialogsnavigator service/instance to appear in Daggers object graph.

Dagger has such convention, remove the @provides convention code of DialogsNavigator in PresentationModule

@Module
class PresentationModule() {

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)
	
	@Provides
    fun dialogsNavigator(fragmentManager: FragmentManager) = DialogsNavigator(fragmentManager)
}

In DialogsNavigator class, we provide a Dagger annotation convention to inject the dependency constructor to create the instance of DialogsNavigator by Dagger itself.

class DialogsNavigator @Inject constructor(private val fragmentManager: FragmentManager) {

    fun showServerErrorDialog() {
        fragmentManager.beginTransaction()
                .add(ServerErrorDialogFragment.newInstance(), null)
                .commitAllowingStateLoss()
    }
}

We use this @Inject annotation to desiginate the constructor to make Dagger to inspect to provide services to the clients

By doing this Dagger annotation processor will inspect this class and notice that it has @Inject annotated constructor and then inspect the dependencies of the constructor which are parameters of constructor and in this case it see the constructor need "fragmentManager" instance and behind the scenes Dagger checks with in its object graph and could see that it has an instnace of fragmentManager(Dagger got the instance of fragmentManager from ActivityModule) and Dagger realize that theres no more required dependencies to construct DialogsNavigator an therefore it constructs instance of DialogsNavigator and adds it to its object graph without required to explicitly provide the @Provides method in PresentationModule like mentioned below.

class PresentationModule() {

    @Provides
    fun viewMvcFactory(layoutInflater: LayoutInflater) = ViewMvcFactory(layoutInflater)

}

hence after using @Inject at the constructor of DialogsNavigator class theres no need of explicit declaration in the PresentationModule, we can remove it

Refactoring the same way by introducing @Inject at all @Provides service in PresentationModule and UserCaseModule

class ViewMvcFactory @Inject constructor(private val layoutInflater: LayoutInflater) {

    fun newQuestionsListViewMvc(parent: ViewGroup?): QuestionsListViewMvc {
        return QuestionsListViewMvc(layoutInflater, parent)
    }

    fun newQuestionDetailsViewMvc(parent: ViewGroup?): QuestionDetailsViewMvc {
        return QuestionDetailsViewMvc(layoutInflater, parent)
    }
}

theres no need to explicitly mention @Provides viewMvcFactory method in Presentation Module, remove it

class PresentationModule() {


}

now PresentationModule is empty, we can delete the PresentationModule and remove it in the PresentationComponent where we mention PresentationModule as a dependencies for PresentationComponent

// Before code change

@PresentationScope
@Subcomponent(modules = [PresentationModule::class, UseCasesModule::class])
interface PresentationComponent {
    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

//After removing PresentationModule file, PresentationCOmponent looks like 

@PresentationScope
@Subcomponent(modules = [UseCasesModule::class])
interface PresentationComponent {
    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

//Doing the same way for UseCaseModule

@Module
class UseCasesModule() {

    @Provides
    fun fetchQuestionsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionsUseCase(stackoverflowApi)

    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}

// using @Inject constructor injection in FetchQuestionsUseCase class

class FetchQuestionsUseCase @Inject constructor(private val stackoverflowApi: StackoverflowApi) {

    sealed class Result {
        data class Success(val questions: List<Question>) : Result()
        object Failure: Result()
    }

    suspend fun fetchLatestQuestions(): Result {
        return withContext(Dispatchers.IO) {
            try {
                val response = stackoverflowApi.lastActiveQuestions(20)
                if (response.isSuccessful && response.body() != null) {
                    return@withContext Result.Success(response.body()!!.questions)
                } else {
                    return@withContext Result.Failure
                }
            } catch (t: Throwable) {
                if (t !is CancellationException) {
                    return@withContext Result.Failure
                } else {
                    throw t
                }
            }
        }
    }
}
// removing fetchQuestionsUseCase @Provides method, as @Inject contructor injection used for FetchQuestionsUseCase // class


@Module
class UseCasesModule() {
 
    @Provides
    fun fetchQuestionDetailsUseCase(stackoverflowApi: StackoverflowApi) = FetchQuestionDetailsUseCase(stackoverflowApi)

}

// using @Inject constructor injection in FetchQuestionDetailsUseCase class
class FetchQuestionDetailsUseCase @Inject constructor(private val stackoverflowApi: StackoverflowApi) {

    sealed class Result {
        data class Success(val question: QuestionWithBody) : Result()
        object Failure: Result()
    }

    suspend fun fetchQuestion(questionId: String): Result {
        return withContext(Dispatchers.IO) {
            try {
                val response = stackoverflowApi.questionDetails(questionId)
                if (response.isSuccessful && response.body() != null) {
                    return@withContext Result.Success(response.body()!!.question)
                } else {
                    return@withContext Result.Failure
                }
            } catch (t: Throwable) {
                if (t !is CancellationException) {
                    return@withContext Result.Failure
                } else {
                    throw t
                }
            }
        }
    }
}

// removing fetchQuestionDetailsUseCase @Provides method, as @Inject contructor injection used for 
// FetchQuestionDetailsUseCase class 


@Module
class UseCasesModule() {

}

now UseCasesModule is empty, we can delete the UseCasesModule class and remove it in the PresentationComponent where we mention UseCasesModule as a dependencies for PresentationComponent

// before code change
@PresentationScope
@Subcomponent(modules = [UseCasesModule::class])
interface PresentationComponent {
    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

//After removing UserCasesModule as dependencies as a module for PresentionComponent

@PresentationScope
@Subcomponent()
interface PresentationComponent {
    fun inject(fragment: QuestionsListFragment)
    fun inject(activity: QuestionDetailsActivity)
}

//In BaseActivity and BaseFragment where we build the PresentionComponent by passing in the PresentationModule and UsecasesModule instance, we have to remove it as Dagger takes care of injecting and add the required instances by the dagger and maintain it in the Dagger object graph. Now PresentationCOmponent doesnt have any modules at all, and all its dependencies are implicitly discovered by Dagger's annotation processor.



// BaseActivity and BaseFragment before code change

open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        appComponent.newActivityComponent(ActivityModule(this))
    }

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent(PresentationModule(), UseCasesModule())
    }

    protected val injector get() = presentationComponent
}

open class BaseFragment: Fragment() {

    private val presentationComponent by lazy {
        (requireActivity() as BaseActivity).activityComponent.newPresentationComponent(
                PresentationModule(), UseCasesModule()
        )
    }

    protected val injector get() = presentationComponent
}

// BaseActivity and BaseFragment after code change of removing PresentationModule and UsecasesModule instance passing into building the PresentationComponent instnace

open class BaseActivity: AppCompatActivity() {

    private val appComponent get() = (application as MyApplication).appComponent

    val activityComponent by lazy {
        appComponent.newActivityComponent(ActivityModule(this))
    }

    private val presentationComponent by lazy {
        activityComponent.newPresentationComponent()
    }

    protected val injector get() = presentationComponent
}

open class BaseFragment: Fragment() {

    private val presentationComponent by lazy {
        (requireActivity() as BaseActivity).activityComponent.newPresentationComponent()
    }

    protected val injector get() = presentationComponent
}

// we have to also remove the functionDeclaration in ActivityComponent, as PresentationCOmponent is a subComponent
of ActivityComponent, we declare a method in ActivityComponent to construct the PresentationComponent

//Before code change in ActivityComponent

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {

    fun newPresentationComponent(
            presentationModule: PresentationModule,
            useCasesModule: UseCasesModule
    ): PresentationComponent

}

//After code change in ActivityComponent, because now theres no need to pass the instance of PresentationModule and UsecasesModule as an instance on building the PresentationComponent, because the services which the PresentaitonModule and UsecasesModule which are supposed to be exposed using @Provides method to get the services to be injected into the client class are automatically created by Dagger by noticing the classes which are defined using the @Inject constructor injection

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {

    fun newPresentationComponent(): PresentationComponent

}


---- Now inspecting ActivityComponent is inspected and find out the relevent services declared in ActivityComponent that can be used with @Inject constructor injection with the same steps we followed for PresentationComponent

//Before code of ActivityComponent

@ActivityScope
@Subcomponent(modules = [ActivityModule::class])
interface ActivityComponent {

    fun newPresentationComponent(): PresentationComponent

}

we could see ActivityComponent is using ActivityModule as dependency, we inspect it


@Module
class ActivityModule(val activity: AppCompatActivity) {

    @Provides
    fun activity() = activity

    @Provides
    @ActivityScope
    fun screensNavigator(activity: AppCompatActivity) = ScreensNavigator(activity)

    @Provides
    fun layoutInflater(activity: AppCompatActivity) = LayoutInflater.from(activity)

    @Provides
    fun fragmentManager(activity: AppCompatActivity) = activity.supportFragmentManager

}

 we could see that ActivityModule exposes 4 services for the client/subcomponents to use it in building their services.

 we can observe that activity is a boot-strap dependency which we get it from outside into the ActivityModule, which is very uch required to be provided using @Provide to use it with in the ActivityModule and to the subComponents of ActivityComponent.

 we can see that layoutInflater and fragmentManager require activity but we dont construct it by ourselves means we dont have access to its constructors. Hence we cant use this "@Inject constructor" methodology for those services(layoutInflater and fragmentManager)

 Hence the only services we can do some changes of using @Inject constructor injection is ScreensNavigator
 We can see the ScreensNavigator is @Scope service (means the instance will maintain the lifecycle of the component of the Scope defines, created only once and the same is supplied everytime and it exist until the lifetime of the Component which its used) Therefore we need to mention the @ActivityScope at the ScreensNavigator class also to still maintain the ScreensNavigator class as Scope service.

Code at ScreensNavigator before removing at the ActivityComponent

class ScreensNavigator (private val activity: AppCompatActivity) {

    fun navigateBack() {
        activity.onBackPressed()
    }

    fun toQuestionDetails(questionId: String) {
        QuestionDetailsActivity.start(activity, questionId)
    }
}

by only doing @Inject constructor injection, Dagger will always create new instance of ScreensNavigator whenever it needs to inject

class ScreensNavigator @Inject constructor(private val activity: AppCompatActivity) {

    fun navigateBack() {
        activity.onBackPressed()
    }

    fun toQuestionDetails(questionId: String) {
        QuestionDetailsActivity.start(activity, questionId)
    }
}

to maintain the ScreensNavigator as @Scope service attached to activity instance. Now Dagger will know to reuse the ScreensNavigator instance whenever needed 

@ActivityScope
class ScreensNavigator @Inject constructor(private val activity: AppCompatActivity) {

    fun navigateBack() {
        activity.onBackPressed()
    }

    fun toQuestionDetails(questionId: String) {
        QuestionDetailsActivity.start(activity, questionId)
    }
}

Conclusion: convention "@Inject contructor" is not constructor injection. Instead of providing services from modules if we inject the dependencies into the constructor it doesnt become a constructor injection. even if we provide services vis modules, we still use constructor injection by injecting the dependencies to build a class from outside explicitly. Hence in both the cases we use constructor injection, when we defines services in modules explicitly, we inject the module instance through constructors explicitly when constructing the component. but by using the above convention, Dagger injects it implicitly and provide the instance of the services to clients
This convention is better to be called as "Automatic-Service-Discovery" because we dont explicitly mention the services in the modules, we just mention the @Inject constructor and Dagger will automatially discovers by parsing the classes which are mentioned with @Injects at constructor and provide the necessary services for the client.


------------- Dagger conventions / steps to use @Inject contructor ---------------
	
    * Dagger can automatically discover services having a public constructor 
      annotated with @Inject annotation.
    
    * Automatically discovered services can be scoped

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
             PROVIDER METHODS IN MODULES Vs AUTOMATIC SERVICE DISCOVERY
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

One reason / aspect to use explicit declaration of services in modules, rather than doing automatic service discovery of useing (@Inject constructor on ServiceProvider classes) :: is for Scope services

Eg : In ScreensNavigator, its a @Scope service (which relys on ActivityScope), we share it with in the bounds of single activity instance. using @Scope is a very important concept in application.

What does it mean fundamentally when a service is scoped ? it means that there i s some kind of state inside that object that is need to be shared among multiple clients (Eg: we use it for Retrofit as @AppScope because Retrofit
maintains some state with in itself for better productivity of network transactions, hence its instance is shared among all network transaction used with in the application. We dont want to create Retrofit instance everytime when theres a network transaction which avoids Retrofit to be used in a productive way). 

Hence @Scope services are more important than others, Therefore its better to keep all this information in one place which gives better readability(in our case we define Retrofit in AppModule using @AppScope). 

When we look at a code base and inspect the modules class, by seeing the @Scope services we can get information about the list of services are shared among the entire application. This readability promotes to better understand the services in code reviews. 

Therefore its better not to make ScreensNavigator to use the "@Inject constructor" convention, as its a @Scope services which used @ActivityScope. Better to make it as explicit declaration with in the ActivityModule as its a @ActivityScope service.

@Module
class ActivityModule(
        val activity: AppCompatActivity
) {

    @Provides
    fun activity() = activity

    @Provides
    @ActivityScope
    fun screensNavigator(activity: AppCompatActivity) = ScreensNavigator(activity)

    @Provides
    fun layoutInflater(activity: AppCompatActivity) = LayoutInflater.from(activity)

    @Provides
    fun fragmentManager(activity: AppCompatActivity) = activity.supportFragmentManager

}


By making this change, in future we can find all @ActivityScope services with in a single place ie: in ActivityModule which provides better readability and maintainability.


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
                                        DAGGER SUMMARY
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------


        Construction Set                                                       Functional Set

        Components                                                                Classes

        Modules                       <==== Convention over   =====>
                                            Configuration
        Scopes                                    ^
                                                  |
        ViewMvcFactory                          In Dagger the interconnection is made using
                                                  |
                                           @Inject annotations
                        (Dagger under the hood uses annotation processing and code generation)                   

Dependency injection framework brings only 2 things to table,
    Template for implementation of Construction set of classes (Dagger will do this using Components, Modules, Scopes). Dependency injection frameworks bring predefined set of conventions that can be used in the application to make the implementation of Dependency injecction architecture pattern in a cleaner / more effecient / more readable. 



----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
                                        ANDROID SERVICES AND DIALOGS
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

Additional Conventions of Dagger, set up dependency injection for services and Dialogs

Setup package of "services" inside "dependencyinjection" package

create "ServiceComponent" and "ServiceModule"

@Module
class ServiceModule(
        val service: Service
) {
    @Provides
    fun context(): Context = service
}

This service instance can be used/injected as Context in required area in all services

@Subcomponent(modules = [ServiceModule::class])
interface ServiceComponent {
    fun newPresentationComponent(): PresentationComponent
}

ServiceComponent will be the subcomponent and it cant be a subcomponent for ActivityComponent, as Services
and Activity have different life cycle, hence it will be subcomponent of AppComponent, we introduce method in AppComponent to create instance of the ServiceComponent

@AppScope
@Component(modules = [AppModule::class])
interface AppComponent {

    fun newActivityComponent(activityModule: ActivityModule): ActivityComponent
    fun newServiceComponent(serviceModule: ServiceModule): ServiceComponent
}

// we create BaseClass for all Services, from there we create instance of the serviceComponent and that can be used by Service clients to inject dependencies required for that client services.

we create a common package which has this BaseClass for Service, called "service" under "common" package


abstract class BaseService: Service() {
    private val appComponent get() = (application as MyApplication).appComponent

    val serviceComponent by lazy {
        appComponent.newServiceComponent(ServiceModule(this))
    }
}

// this is the dependency injection infrastructure for services

----------------------------------------------------------------------------------------------------------
                                        DI FOR ANDROID DIALOGS
----------------------------------------------------------------------------------------------------------

Its not good approach to define dialogs inside activities and fragments, especially if the dialogs are complex.
Its always recommend to have Dialogs in stand-alone classes.

Dialogs are like activities and Fragments even if you implement using Dialog class / custom Views, are basically Conrollers(in MVC). Better have a proper DI setup for them.

Since dialogs are part of Presentation layer like Activites and Fragments , we can reuse PresentationComponent for
DI into Dialogs. Basically Activities, Fragments and Dialogs share the same object graph in DependencyInjection(DI)

setup a new file in common.dialogs.BaseDialog.kt

Better to use DialogFragment class in android, because they have lifecycle(better can be utilized for complex flows). DialogFragment is retained in configurationchanged and processed. In complex flows, the onStart() and OnStop() callbacks will be useful to process some logic.


open class BaseDialog: DialogFragment() {
    private val presentationComponent = (requireActivity() as                   
                                                BaseActivity).activityComponent.newPresentationComponent()

    protected val injector get() = presentationComponent
}

now all dialogs that extends this BaseDialog will be able to get this presentationComponent, 

using the above BaseDialog we refactor ServerErrorDialogFragment



In future, if we define some complex dialogs which extends the BaseDialog will be able to access / services can be injected which are in the object graph of the PresentationComponent, since presentationCOmponent is available inside the Dialogs and its available in parent(BaseDialog). To inject the services into the Dialogs, we can define the inject method/target of the client(like we did for QuestionDetailsActivity "fun inject(activity: QuestionDetailsActivity)") inside PresentationComponent.



----------------------------------------------------------------------------------------------------------
                            STATIC PROVIDER METHODS AND COMPONENT BUILDERS
----------------------------------------------------------------------------------------------------------






